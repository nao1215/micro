// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package sagadb

import (
	"context"
	"time"
)

const completeSaga = `-- name: CompleteSaga :exec
UPDATE sagas
SET status = 'completed', updated_at = datetime('now'), completed_at = datetime('now')
WHERE id = ?
`

func (q *Queries) CompleteSaga(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, completeSaga, id)
	return err
}

const createSaga = `-- name: CreateSaga :exec
INSERT INTO sagas (id, saga_type, current_step, status, payload, started_at, updated_at)
VALUES (?, ?, ?, 'started', ?, datetime('now'), datetime('now'))
`

type CreateSagaParams struct {
	ID          string
	SagaType    string
	CurrentStep string
	Payload     string
}

func (q *Queries) CreateSaga(ctx context.Context, arg CreateSagaParams) error {
	_, err := q.db.ExecContext(ctx, createSaga,
		arg.ID,
		arg.SagaType,
		arg.CurrentStep,
		arg.Payload,
	)
	return err
}

const createSagaStep = `-- name: CreateSagaStep :exec
INSERT INTO saga_steps (id, saga_id, step_name, status, result, started_at)
VALUES (?, ?, ?, ?, '{}', datetime('now'))
`

type CreateSagaStepParams struct {
	ID       string
	SagaID   string
	StepName string
	Status   string
}

func (q *Queries) CreateSagaStep(ctx context.Context, arg CreateSagaStepParams) error {
	_, err := q.db.ExecContext(ctx, createSagaStep,
		arg.ID,
		arg.SagaID,
		arg.StepName,
		arg.Status,
	)
	return err
}

const failSaga = `-- name: FailSaga :exec
UPDATE sagas
SET status = 'failed', updated_at = datetime('now'), completed_at = datetime('now')
WHERE id = ?
`

func (q *Queries) FailSaga(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, failSaga, id)
	return err
}

const getProjectorOffset = `-- name: GetProjectorOffset :one
SELECT last_timestamp FROM projector_offsets WHERE id = 'default'
`

func (q *Queries) GetProjectorOffset(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getProjectorOffset)
	var last_timestamp time.Time
	err := row.Scan(&last_timestamp)
	return last_timestamp, err
}

const getSagaByID = `-- name: GetSagaByID :one
SELECT id, saga_type, current_step, status, payload, started_at, updated_at, completed_at
FROM sagas
WHERE id = ?
`

func (q *Queries) GetSagaByID(ctx context.Context, id string) (Saga, error) {
	row := q.db.QueryRowContext(ctx, getSagaByID, id)
	var i Saga
	err := row.Scan(
		&i.ID,
		&i.SagaType,
		&i.CurrentStep,
		&i.Status,
		&i.Payload,
		&i.StartedAt,
		&i.UpdatedAt,
		&i.CompletedAt,
	)
	return i, err
}

const listActiveSagas = `-- name: ListActiveSagas :many
SELECT id, saga_type, current_step, status, payload, started_at, updated_at, completed_at
FROM sagas
WHERE status IN ('started', 'in_progress', 'compensating')
ORDER BY started_at ASC
`

func (q *Queries) ListActiveSagas(ctx context.Context) ([]Saga, error) {
	rows, err := q.db.QueryContext(ctx, listActiveSagas)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Saga
	for rows.Next() {
		var i Saga
		if err := rows.Scan(
			&i.ID,
			&i.SagaType,
			&i.CurrentStep,
			&i.Status,
			&i.Payload,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listSagaSteps = `-- name: ListSagaSteps :many
SELECT id, saga_id, step_name, status, result, started_at, completed_at, retry_count, last_error
FROM saga_steps
WHERE saga_id = ?
ORDER BY started_at ASC
`

func (q *Queries) ListSagaSteps(ctx context.Context, sagaID string) ([]SagaStep, error) {
	rows, err := q.db.QueryContext(ctx, listSagaSteps, sagaID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []SagaStep
	for rows.Next() {
		var i SagaStep
		if err := rows.Scan(
			&i.ID,
			&i.SagaID,
			&i.StepName,
			&i.Status,
			&i.Result,
			&i.StartedAt,
			&i.CompletedAt,
			&i.RetryCount,
			&i.LastError,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listStuckSagas = `-- name: ListStuckSagas :many
SELECT id, saga_type, current_step, status, payload, started_at, updated_at, completed_at
FROM sagas
WHERE status IN ('in_progress', 'compensating')
  AND updated_at < ?
ORDER BY updated_at ASC
`

func (q *Queries) ListStuckSagas(ctx context.Context, updatedAt time.Time) ([]Saga, error) {
	rows, err := q.db.QueryContext(ctx, listStuckSagas, updatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Saga
	for rows.Next() {
		var i Saga
		if err := rows.Scan(
			&i.ID,
			&i.SagaType,
			&i.CurrentStep,
			&i.Status,
			&i.Payload,
			&i.StartedAt,
			&i.UpdatedAt,
			&i.CompletedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateSagaStep = `-- name: UpdateSagaStep :exec
UPDATE sagas
SET current_step = ?, status = ?, payload = ?, updated_at = datetime('now')
WHERE id = ?
`

type UpdateSagaStepParams struct {
	CurrentStep string
	Status      string
	Payload     string
	ID          string
}

func (q *Queries) UpdateSagaStep(ctx context.Context, arg UpdateSagaStepParams) error {
	_, err := q.db.ExecContext(ctx, updateSagaStep,
		arg.CurrentStep,
		arg.Status,
		arg.Payload,
		arg.ID,
	)
	return err
}

const updateSagaStepRetry = `-- name: UpdateSagaStepRetry :exec
UPDATE saga_steps
SET retry_count = ?, last_error = ?, status = ?
WHERE id = ?
`

type UpdateSagaStepRetryParams struct {
	RetryCount int64
	LastError  string
	Status     string
	ID         string
}

func (q *Queries) UpdateSagaStepRetry(ctx context.Context, arg UpdateSagaStepRetryParams) error {
	_, err := q.db.ExecContext(ctx, updateSagaStepRetry,
		arg.RetryCount,
		arg.LastError,
		arg.Status,
		arg.ID,
	)
	return err
}

const updateSagaStepStatus = `-- name: UpdateSagaStepStatus :exec
UPDATE saga_steps
SET status = ?, result = ?, completed_at = datetime('now')
WHERE id = ?
`

type UpdateSagaStepStatusParams struct {
	Status string
	Result string
	ID     string
}

func (q *Queries) UpdateSagaStepStatus(ctx context.Context, arg UpdateSagaStepStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateSagaStepStatus, arg.Status, arg.Result, arg.ID)
	return err
}

const upsertProjectorOffset = `-- name: UpsertProjectorOffset :exec
INSERT INTO projector_offsets (id, last_timestamp, updated_at)
VALUES ('default', ?, datetime('now'))
ON CONFLICT(id) DO UPDATE SET last_timestamp = excluded.last_timestamp, updated_at = datetime('now')
`

func (q *Queries) UpsertProjectorOffset(ctx context.Context, lastTimestamp time.Time) error {
	_, err := q.db.ExecContext(ctx, upsertProjectorOffset, lastTimestamp)
	return err
}
