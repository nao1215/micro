// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: query.sql

package mediadb

import (
	"context"
	"database/sql"
	"time"
)

const deleteAllMediaReadModels = `-- name: DeleteAllMediaReadModels :exec
DELETE FROM media_read_models
`

func (q *Queries) DeleteAllMediaReadModels(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllMediaReadModels)
	return err
}

const getMediaByID = `-- name: GetMediaByID :one
SELECT id, user_id, filename, content_type, size, storage_path,
       thumbnail_path, width, height, duration_seconds,
       status, last_event_version, uploaded_at, updated_at
FROM media_read_models
WHERE id = ?
`

func (q *Queries) GetMediaByID(ctx context.Context, id string) (MediaReadModel, error) {
	row := q.db.QueryRowContext(ctx, getMediaByID, id)
	var i MediaReadModel
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.Filename,
		&i.ContentType,
		&i.Size,
		&i.StoragePath,
		&i.ThumbnailPath,
		&i.Width,
		&i.Height,
		&i.DurationSeconds,
		&i.Status,
		&i.LastEventVersion,
		&i.UploadedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getProjectorOffset = `-- name: GetProjectorOffset :one
SELECT last_timestamp FROM projector_offsets WHERE id = 'default'
`

func (q *Queries) GetProjectorOffset(ctx context.Context) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, getProjectorOffset)
	var last_timestamp time.Time
	err := row.Scan(&last_timestamp)
	return last_timestamp, err
}

const listAllMedia = `-- name: ListAllMedia :many
SELECT id, user_id, filename, content_type, size, storage_path,
       thumbnail_path, width, height, duration_seconds,
       status, last_event_version, uploaded_at, updated_at
FROM media_read_models
WHERE status != 'deleted'
ORDER BY uploaded_at DESC
`

func (q *Queries) ListAllMedia(ctx context.Context) ([]MediaReadModel, error) {
	rows, err := q.db.QueryContext(ctx, listAllMedia)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaReadModel
	for rows.Next() {
		var i MediaReadModel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.ContentType,
			&i.Size,
			&i.StoragePath,
			&i.ThumbnailPath,
			&i.Width,
			&i.Height,
			&i.DurationSeconds,
			&i.Status,
			&i.LastEventVersion,
			&i.UploadedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listMediaByUserID = `-- name: ListMediaByUserID :many
SELECT id, user_id, filename, content_type, size, storage_path,
       thumbnail_path, width, height, duration_seconds,
       status, last_event_version, uploaded_at, updated_at
FROM media_read_models
WHERE user_id = ? AND status != 'deleted'
ORDER BY uploaded_at DESC
`

func (q *Queries) ListMediaByUserID(ctx context.Context, userID string) ([]MediaReadModel, error) {
	rows, err := q.db.QueryContext(ctx, listMediaByUserID, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaReadModel
	for rows.Next() {
		var i MediaReadModel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.ContentType,
			&i.Size,
			&i.StoragePath,
			&i.ThumbnailPath,
			&i.Width,
			&i.Height,
			&i.DurationSeconds,
			&i.Status,
			&i.LastEventVersion,
			&i.UploadedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const searchMedia = `-- name: SearchMedia :many
SELECT id, user_id, filename, content_type, size, storage_path,
       thumbnail_path, width, height, duration_seconds,
       status, last_event_version, uploaded_at, updated_at
FROM media_read_models
WHERE filename LIKE ? AND status != 'deleted'
ORDER BY uploaded_at DESC
`

func (q *Queries) SearchMedia(ctx context.Context, filename string) ([]MediaReadModel, error) {
	rows, err := q.db.QueryContext(ctx, searchMedia, filename)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []MediaReadModel
	for rows.Next() {
		var i MediaReadModel
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.Filename,
			&i.ContentType,
			&i.Size,
			&i.StoragePath,
			&i.ThumbnailPath,
			&i.Width,
			&i.Height,
			&i.DurationSeconds,
			&i.Status,
			&i.LastEventVersion,
			&i.UploadedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateMediaProcessed = `-- name: UpdateMediaProcessed :exec
UPDATE media_read_models
SET thumbnail_path = ?,
    width = ?,
    height = ?,
    duration_seconds = ?,
    status = 'processed',
    last_event_version = ?,
    updated_at = datetime('now')
WHERE id = ?
`

type UpdateMediaProcessedParams struct {
	ThumbnailPath    sql.NullString
	Width            sql.NullInt64
	Height           sql.NullInt64
	DurationSeconds  sql.NullFloat64
	LastEventVersion int64
	ID               string
}

func (q *Queries) UpdateMediaProcessed(ctx context.Context, arg UpdateMediaProcessedParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaProcessed,
		arg.ThumbnailPath,
		arg.Width,
		arg.Height,
		arg.DurationSeconds,
		arg.LastEventVersion,
		arg.ID,
	)
	return err
}

const updateMediaStatus = `-- name: UpdateMediaStatus :exec
UPDATE media_read_models
SET status = ?,
    last_event_version = ?,
    updated_at = datetime('now')
WHERE id = ?
`

type UpdateMediaStatusParams struct {
	Status           string
	LastEventVersion int64
	ID               string
}

func (q *Queries) UpdateMediaStatus(ctx context.Context, arg UpdateMediaStatusParams) error {
	_, err := q.db.ExecContext(ctx, updateMediaStatus, arg.Status, arg.LastEventVersion, arg.ID)
	return err
}

const upsertMediaReadModel = `-- name: UpsertMediaReadModel :exec
INSERT INTO media_read_models (id, user_id, filename, content_type, size, storage_path, status, last_event_version, uploaded_at, updated_at)
VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, datetime('now'))
ON CONFLICT(id) DO UPDATE SET
    status = excluded.status,
    last_event_version = excluded.last_event_version,
    updated_at = datetime('now')
`

type UpsertMediaReadModelParams struct {
	ID               string
	UserID           string
	Filename         string
	ContentType      string
	Size             int64
	StoragePath      string
	Status           string
	LastEventVersion int64
	UploadedAt       time.Time
}

func (q *Queries) UpsertMediaReadModel(ctx context.Context, arg UpsertMediaReadModelParams) error {
	_, err := q.db.ExecContext(ctx, upsertMediaReadModel,
		arg.ID,
		arg.UserID,
		arg.Filename,
		arg.ContentType,
		arg.Size,
		arg.StoragePath,
		arg.Status,
		arg.LastEventVersion,
		arg.UploadedAt,
	)
	return err
}

const upsertProjectorOffset = `-- name: UpsertProjectorOffset :exec
INSERT INTO projector_offsets (id, last_timestamp, updated_at)
VALUES ('default', ?, datetime('now'))
ON CONFLICT(id) DO UPDATE SET last_timestamp = excluded.last_timestamp, updated_at = datetime('now')
`

func (q *Queries) UpsertProjectorOffset(ctx context.Context, lastTimestamp time.Time) error {
	_, err := q.db.ExecContext(ctx, upsertProjectorOffset, lastTimestamp)
	return err
}
